/* Generated By:JavaCC: Do not edit this line. SimpleCharStream.java Version 2.1 */
package dods.dap.parser;

import java.nio.charset.StandardCharsets;

/**
 * An implementation of interface CharStream, where the stream is assumed to contain only ASCII
 * characters (without unicode processing).
 */
public final class SimpleCharStream {
  public static final boolean staticFlag = false;
  int bufsize;
  int available;
  int tokenBegin;
  public int bufpos = -1;
  private int bufline[];
  private int bufcolumn[];

  private int column = 0;
  private int line = 1;

  private boolean prevCharIsCR = false;
  private boolean prevCharIsLF = false;

  private java.io.Reader inputStream;

  private char[] buffer;
  private int maxNextCharInd = 0;
  private int inBuf = 0;

  private final void ExpandBuff(boolean wrapAround) {
    char[] newbuffer = new char[bufsize + 2048];
    int newbufline[] = new int[bufsize + 2048];
    int newbufcolumn[] = new int[bufsize + 2048];

    try {
      if (wrapAround) {
        System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);
        System.arraycopy(buffer, 0, newbuffer, bufsize - tokenBegin, bufpos);
        buffer = newbuffer;

        System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);
        System.arraycopy(bufline, 0, newbufline, bufsize - tokenBegin, bufpos);
        bufline = newbufline;

        System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);
        System.arraycopy(bufcolumn, 0, newbufcolumn, bufsize - tokenBegin, bufpos);
        bufcolumn = newbufcolumn;

        maxNextCharInd = (bufpos += (bufsize - tokenBegin));
      } else {
        System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);
        buffer = newbuffer;

        System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);
        bufline = newbufline;

        System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);
        bufcolumn = newbufcolumn;

        maxNextCharInd = (bufpos -= tokenBegin);
      }
    } catch (Throwable t) {
      throw new Error(t.getMessage());
    }

    bufsize += 2048;
    available = bufsize;
    tokenBegin = 0;
  }

  private final void FillBuff() throws java.io.IOException {
    if (maxNextCharInd == available) {
      if (available == bufsize) {
        if (tokenBegin > 2048) {
          bufpos = maxNextCharInd = 0;
          available = tokenBegin;
        } else if (tokenBegin < 0) bufpos = maxNextCharInd = 0;
        else ExpandBuff(false);
      } else if (available > tokenBegin) available = bufsize;
      else if ((tokenBegin - available) < 2048) ExpandBuff(true);
      else available = tokenBegin;
    }

    int i;
    try {
      if ((i = inputStream.read(buffer, maxNextCharInd, available - maxNextCharInd)) == -1) {
        inputStream.close();
        throw new java.io.IOException();
      } else maxNextCharInd += i;
      return;
    } catch (java.io.IOException e) {
      --bufpos;
      backup(0);
      if (tokenBegin == -1) tokenBegin = bufpos;
      throw e;
    }
  }

  public final char BeginToken() throws java.io.IOException {
    tokenBegin = -1;
    char c = readChar();
    tokenBegin = bufpos;

    return c;
  }

  private final void UpdateLineColumn(char c) {
    column++;

    if (prevCharIsLF) {
      prevCharIsLF = false;
      column = 1;
      line += column;
    } else if (prevCharIsCR) {
      prevCharIsCR = false;
      if (c == '\n') {
        prevCharIsLF = true;
      } else {
        column = 1;
        line += column;
      }
    }

    switch (c) {
      case '\r':
        prevCharIsCR = true;
        break;
      case '\n':
        prevCharIsLF = true;
        break;
      case '\t':
        column--;
        column += (8 - (column & 07));
        break;
      default:
        break;
    }

    bufline[bufpos] = line;
    bufcolumn[bufpos] = column;
  }

  public final char readChar() throws java.io.IOException {
    if (inBuf > 0) {
      --inBuf;

      if (++bufpos == bufsize) bufpos = 0;

      return buffer[bufpos];
    }

    if (++bufpos >= maxNextCharInd) FillBuff();

    char c = buffer[bufpos];

    UpdateLineColumn(c);
    return c;
  }

  public final int getEndColumn() {
    return bufcolumn[bufpos];
  }

  public final int getEndLine() {
    return bufline[bufpos];
  }

  public final int getBeginColumn() {
    return bufcolumn[tokenBegin];
  }

  public final int getBeginLine() {
    return bufline[tokenBegin];
  }

  public final void backup(int amount) {

    inBuf += amount;
    if ((bufpos -= amount) < 0) bufpos += bufsize;
  }

  public SimpleCharStream(java.io.Reader dstream, int startline, int startcolumn, int buffersize) {
    inputStream = dstream;
    line = startline;
    column = startcolumn - 1;

    available = bufsize = buffersize;
    buffer = new char[buffersize];
    bufline = new int[buffersize];
    bufcolumn = new int[buffersize];
  }

  public SimpleCharStream(java.io.Reader dstream, int startline, int startcolumn) {
    this(dstream, startline, startcolumn, 4096);
  }

  public SimpleCharStream(
      java.io.InputStream dstream,
      int startline,
      int startcolumn,
      int buffersize) { // 2012-06-17 Bob Simons changed from new InputStreamReader(no charset)
    this(iso8859Reader(dstream), startline, startcolumn, buffersize);
  }

  /**
   * 2012-06-17 Bob Simons added this to specify "ISO-8859-1" (which is better than default charset,
   * especially on a Mac). This is not ideal. Ideal would be to use charset found in header. But DDS
   * is odd in that top of DataDDS is text and lower part is binary. So it is not trivial for me to
   * change code to properly deal with this.
   */
  public static java.io.InputStreamReader iso8859Reader(java.io.InputStream is) {
    return new java.io.InputStreamReader(is, StandardCharsets.ISO_8859_1);
  }

  public SimpleCharStream(java.io.InputStream dstream, int startline, int startcolumn) {
    this(dstream, startline, startcolumn, 4096);
  }

  public final String GetImage() {
    if (bufpos >= tokenBegin) return new String(buffer, tokenBegin, bufpos - tokenBegin + 1);
    else
      return new String(buffer, tokenBegin, bufsize - tokenBegin)
          + new String(buffer, 0, bufpos + 1);
  }
}
